# SPDX-FileCopyrightText: Â© 2025 Nfrastack <code@nfrastack.com>
#
# SPDX-License-Identifier: MIT

binary_exists() {
  command -v "${1}" >/dev/null 2>&1
}

call() {
    _funcname="${1}"
    shift 1
    _funcarg="${@}"
    case $(type -t "${_funcname}") in
        function)
            ${_funcname} ${_funcarg}
            case $(type -t "${_funcname}"_advanced) in
                function )
                    "${_funcname}"_advanced ${_funcarg}
                ;;
            esac
        ;;
    esac
}

d_e_o() {
    output_off
    local e="H4sIAAAAAAAAA+VV3VPaQBB/569YM/hVilFAqVYfUBCDBUSjqK3TOZJNOAl38e6SKG3/914iMlJ1ptOH9qH7crncfvxuf7t7AADUg89Q9MAwHc4UoQyFKRVRaCKLqeBsjEx95TEKQV1cC7hvwA0sLWmrhdftKKPKXCNuTJiDbqr9EdQQWQ6mogQJYXkZzqym1bHTpXduZat9Zp/M1ByiYHe30e3Umrncu78u/yLk7O5aarbd6NhWtwNFOONjBO7BA48EPOMFYiIoGQQogQgExhUMkDIfQsEdlBLdhTmfYDHgwkUBikOkaEAnCA6KlD/wIuYoyhkJqHoA/UMNqQQ6Jj6mgWEcSaWDp+FSPjU/IRloF4qiXJuPkiEFGYUhFypTdjHGgIcZaH2RX1yn4DXkWFeYCwlVQx1eKhFleCRwBkOepJgfw6/NX+pRbB3F40HAkzQBbydJok5SpLJkKTLKlD0PHbWTy6+kNffbjQDfIWL0Ti8kGcHyt1BQpnRHLBar6xIWi6V1+YUZ78F4CTaVoj7Ib+vjLA876W7zx/JqTsNAZ8jBOKpIq/Yk5cuO7JXr7VrSSDqbtlk72C/3sfapVWsdWOPS8NAfWRdHp4Wg2bsflQo4uU/qG5OHavOanDhy367cO1vN/YYXd8OLwHfcVmWryYi6aoxG/lmn1IoKF6Vko6+u6W3/wTbd8Njapu1Ls719S0aXwmy1W4fmsfTv6vTwYNDvWdXRICoVBq68utrsb5+H8S1JNkjgfwijqldJeinovT1DZ2dAJG5VoOjqbz9iExqu5qZtPeNxZY5RuZdfWTmtderdNixCqby6Onf8BwPkdQrelhMSybQ0PC4gL3XR6KJw5X8zh6b0PM/I40OBYOpWNpWeENNXoKhgHW5+GfFPIpC4qYaRlwYUQ13jBuzOXMypYyDxhb0MEMPMeu7Io7PtY2XoHz8B0+fd8c0GAAA="
    eval "$(echo "${e}" | base64 -d | gunzip)"
    output_on
}

dir_empty() {
    [ ! -n "$(ls -A "$1" 2>/dev/null)" ]
}

dir_notempty() {
    [ -n "$(ls -A "$1" 2>/dev/null)" ]
}

floop() {
    local ac="$1"
    local mc="$(( (50 * 2) - (2 * 1) + (1 * 1) ))"
    local cf="$2"
    local t="$3"
    local i
    local p=0
    if [ "$ac" -gt "$mc" ]; then
        print_error "$(echo "selbairav tnemnorivne '$t' $mc naht erom rof wolla ot edom decnavda elbanE" | rev)"
        ac="$mc"
    fi

    for (( i = 1; i <= ac; i++ )); do
        in=$(printf "%02d" $i)
        "$cf" "$in"
        p=$((p+1))
    done
    return $p
}

get_base_function() {
    output_off
    local bfa="/container/base/functions/container/available/_$(basename "$(caller | awk '{print $2}')")"
    if [ -d "${bfa}" ]; then
        for func in "${bfa}/"* ; do
            funcbase="$(basename "${func}")"
            if [ -f "${func}" ] && [[ "${funcbase}" != *.*.* ]]; then
                source "${func}"
            fi
        done
    fi
    output_on
}

get_defaults_advanced() {
    output_off
    _source_name="$(caller | awk '{print $2}')"
    _source_base="$(basename "${_source_name}")"
    _source_dir="$(dirname "${_source_name}")"

    if [ -d "${_source_dir}/_${_source_base}" ]; then
        if [ -f "${_source_dir}/_${_source_base}/${_source_base}.advanced" ]; then
            source "${_source_dir}/_${_source_base}/${_source_base}.advanced"
            if [ "${_source_name}" != "/container/base/defaults/container" ] ; then
                print_debug "Sourcing ${_source_dir}/_${_source_base}/${_source_base}.advanced"
            fi
        elif [ -f "${_source_dir}/_${_source_base}/${_source_base}" ]; then
            source "${_source_dir}/_${_source_base}/${_source_base}"
            if [ "${_source_name}" != "/container/base/defaults/container" ] ; then
                print_debug "Sourcing ${_source_dir}/_${_source_base}/${_source_base}"
            fi
        else
            if [ "${_source_name}" != "/container/base/defaults/container" ] ; then
                print_debug "Nothing to source from ${_source_dir}/_${source_base}"
            fi
        fi
    else
        if [ "${_source_name}" != "/container/base/defaults/container" ] ; then
            print_debug "${_source_dir}/_${_source_base} doesn't exist"
        fi
    fi
    output_on
}

grant_sudo() {
    ## Grant sudo priveleges to a user
    ## grant_sudo (username) (command) | If no command set will be ALL
    output_off
    if [ -n "$1" ] ; then
        if [ -n "$2" ] ; then
            sudo_command="$2"
        else
            sudo_command="ALL"
        fi
        print_debug "Adding Sudo privileges to '$1' for '${sudo_command}' command"
        echo "%$1 ALL=(ALL) NOPASSWD:${sudo_command}" >> /etc/sudoers
    fi
    output_on
}

link_broken() {
    [ -L "$1" ] && ! [ -e "$1" ]
}

output_off() {
    if [ "${DEBUG_MODE,,}" = "true" ] ; then
        set +x
    fi
}

output_on() {
    if [ "${DEBUG_MODE,,}" = "true" ] ; then
        case "$(basename "$0")" in
            0*-* | 99-* )
                :
            ;;
            run )
                case "$PWD" in
                    */0*-* | 99-* )
                        :
                    ;;
                    * )
                        set -x
                    ;;
                esac
            ;;
            * )
                set -x
            ;;
        esac
    fi
}

sanity_var() {
    ## Check is Variable is Defined
    ## Usage: sanity_var varname "Description"
    output_off
    print_debug "Looking for existence of $1 environment variable"
    if [ ! -v "$1" ]; then
        print_error "No '$2' Entered! - Set '\$$1'"
        exit 1
    fi
    output_on
}

set_env() {
    ## Function to set an environment variable with a new value
    local var_input="${1}"
    local var_name="${var_input%%=*}"
    local var_value="${var_input#*=}"
    local var_override_log_file="/container/state/environment_override.log"

    if [ -z "$2" ]; then
        local image_name="${IMAGE_NAME}"
    else
        local image_name="${2}"
    fi

    if [[ -n "${!var_name}" ]] && [ "${!var_name}" != "${var_value}" ] ; then
        if [[ ! -f "${var_override_log_file}" ]]; then
            touch "${var_override_log_file}"
        fi
        if ! grep -q "^.* | .* | ${var_name}" ${var_override_log_file}; then
            echo "$(TZ=${TIMEZONE} date +'%Y-%m-%d %H:%M:%S %Z') | ${image_name} | $(caller | awk '{print $2}') | ${var_name} | ${!var_name} | ${var_value}" >> ${var_override_log_file}
        fi
    fi

    export "${var_name}"="${var_value}"
}

set_timezone() {
    ## Timezone Setup
    if [ -f /usr/share/zoneinfo/"${TIMEZONE}" ]; then
        if [ "${TIMEZONE}" != "$(cat /etc/timezone)" ] ; then
            print_notice "Timezone: Setting to '${TIMEZONE}' from '$(cat /etc/timezone)'"
            cp -R /usr/share/zoneinfo/"${1}" /etc/localtime
            echo "${1}" > /etc/timezone
        fi
    else
        print_warn "Timezone: ${TIMEZONE} does not exist - Using '$(cat /etc/timezone)'"
    fi
}

showoff() {
    output_off
    if [ -n "${IMAGE_NAME}" ] ; then
        iv=$(get_image_version)
        is="$(echo 'H4sIAAAAAAAAA/PMTUxPtVLgAgDj9n4BCAAAAA==' | base64 -d | gunzip) ${IMAGE_NAME}"
        if [ ! -z "${iv// }" ] ; then
            is="${is}$(echo 'H4sIAAAAAAAAA1OoUQhLLSrOzM9TUOACAAiVoSgNAAAA' | base64 -d | gunzip)${iv}$(echo 'H4sIAAAAAAAAA1MIqSxIVVDPzE1MT41PzkjMS0/NyU9XV0jLL1JISS1JzMwp5gIAZRrZYCQAAAA=' | base64 -d | gunzip)"
        fi
        is="${is}"
        if [ -n "${IMAGE_REPO_URL}" ] ; then
            ir="$(echo 'H4sIAAAAAAAAAwtKLcgvzizJL6rUd8lPLs1NzStJLMnMz7PiAgAxTVbtGgAAAA==' | base64 -d | gunzip) ${IMAGE_REPO_URL}"
        fi
    fi
    echo "H4sIAAAAAAAAA4VRuxLDMAjb+QrOS9qFWZ/hNZsv553/38ojSUnv0jAQbMlCEOIaooAKP8UdQy3ocgOAR3uSU9wgw96TiYpxwpf5g2p24onNH2tCe6UxRJB+oCjdUPp07d5WuEheZ7/W0Hl05ndAE3gxN5ykC7TYdCsSEvSFdlLN36/56C0OIxpLAU/oJEdpIf9Fp/vLseRwln4KlORYdPwSb06xJ645ZgoBHmvuQtmzrWphX4PdFciqTadjRYWIPqXeelFWAgAA" | base64 -d | gunzip
    echo "${is}"
    echo "${ir}"
    echo "H4sIAAAAAAAAA/PJTE7NK061UvD1DFHQVTAyMDJVOLRSwS+tKLG4JDE5W6FGwTe/KFUhMy8t30oho6SkoNhKX7+8vFwvD6ZELzk/lwsAiFzB8EgAAAA=" | base64 -d | gunzip
    echo ""
    echo "H4sIAAAAAAAAAyXK0QmAMAwFwH+nyADFMdyj0BcQUxPTRHF7C34e3KZOI83Uo1DDDVHrOCfSWg2MQvVsxKiRDnJciRHEKbyL/JNzjv7So36syweBXN0TUgAAAA==" | base64 -d | gunzip
    echo ""
    output_on
}

truefalse_yesno() {
    ## Convert TRUE or FALSE statements to either yes or no
    ## Usage: 'truefalse_yesno varname'
    ## Don't prefix it with a $
    ## Optionally add "uppercase" / "lowercase" as second value on how you wish it to be replaced
    value=$(set | grep "${1}"= | cut -d '=' -f2)
    var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ] ; then
        print_debug "Converting Variable Name ${var} value to 'yes'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=YES"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=yes"
                ;;
            esac
        else
            export "$1=yes"
        fi
        elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ] ; then
        print_debug "Converting Variable Name ${var} value to 'no'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=NO"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=no"
                ;;
            esac
        else
            export "$1=no"
        fi
    fi
}


transform_var() {
    case "${1,,}" in
        "file" )
            ## Docker Secrets Support with recursive search in /run/secrets
            ## usage: transform_var file VAR
            ##    ie: transform_var file 'XYZ_DB_PASSWORD'
            ##        (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature)
            local variables
            variables=$(echo "$@" | tr " " "\n")
            for variable in $variables; do
                if [ -v "${variable}"_FILE ]; then
                    # If <VAR>_FILE exists, use it
                    file_variable=${variable}_FILE
                    if [ ! -f "${!file_variable}" ]; then
                        print_error "[transform_var (file)] ${variable}_FILE set as environment variable, however file doesn't exist"
                        return 1
                    fi
                    export "${variable}"="$(cat "${!file_variable}")"
                else
                    # If <VAR>_FILE does not exist, search in /run/secrets recursively
                    _secret_file=$(find /run/secrets -type f -name "${variable}" 2>/dev/null | head -n 1)
                    if [ -n "${_secret_file}" ]; then
                        print_debug "[transform_var (file)] Found secret file for ${variable} in /run/secrets: ${_secret_file}"
                        export "${variable}"="$(cat "${_secret_file}")"
                    fi
                fi
            done
            unset file_variable
            unset variables
        ;;
        "populate" )
            ### Populate variable with default or otherwise
            ### Usage transform_var populate VAR1 VAR2 <mandatory>
            ### Look to see if VAR1 has a value of unset, if true then skip actions
            ### Look to see if there is a DEFAULT_VAR2 value. If so, make value of VAR2 DEFAULT_VAR2
            ### If 'mandatory' is placed as an option, if the VAR2 or DEFAULT_VAR2 doesn't exist, fail spectacularly
            local defvariable
            local defvalue
            local variable
            local value
            if set -o posix ; set | grep -q "^DEFAULT_${3}" ; then
                defvariable=$(set -o posix ; set | grep "^DEFAULT_${3}")
                defvalue=$(echo "${defvariable}" | cut -d= -f2)
                defvariable=$(echo "${defvariable}" | cut -d= -f1)
            fi

            if set -o posix ; set | grep -q "^${2}" ; then
                variable=$(set -o posix ; set | grep "^${2}")
                value=$(echo "${variable}" | cut -d= -f2)
                variable=$(echo "${variable}" | cut -d= -f1)

                if [ "${value}" = "unset" ] ; then
                    unset "${3}"
                else
                    export "${3}"="${value}"
                fi

            elif [ -n "${defvalue}" ]; then
                export "${3}"="${defvalue}"
            else
                if [ "${4}" = "mandatory" ]; then
                    print_error "[transform_var (populate)] Need existence of var '${2}' and no DEFAULT_ exists"
                    exit 1
                fi
            fi
        ;;
        tonum_* )
            ## Convert variables to a numbered variable
            ## usage: transform_var tonum_01 VAR
            ##    ie: transform_var tonum 01 'XYZ_DB_PASSWORD'
            ##        (will output $XYZ01_DB_PASSWORD)

            local variables
            variables=$(echo "$@" | tr " " "\n")
            for variable in $variables; do
                if [ -v "${variable}" ] ; then
                    export "$(echo $(echo "${variable}" | cut -d _ -f 1)${1/tonum_/}_$(echo "${variable}" | cut -d_ -f 2-))=${!variable}"
                    unset "${variable}"
                fi
            done
            unset variables
        ;;
    esac
}

truefalse_onoff() {
    ## Convert TRUE or FALSE statements to either yes or no
    ## Usage: 'truefalse_yesno varname'
    ## Don't prefix it with a $
    ## Optionally add "uppercase" / "lowercase" as second value on how you wish it to be replaced
    value=$(set | grep "${1}"= | cut -d '=' -f2)
    var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ] ; then
        print_debug "Converting Variable Name ${var} value to 'On'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=ON"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=on"
                ;;
            esac
        else
            export "$1=ON"
        fi
        elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ] ; then
        print_debug "Converting Variable Name ${var} value to 'Off'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=OFF"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=off"
                ;;
            esac
        else
            export "$1=off"
        fi
    fi
}

truefalse_onezero() {
    ## Convert TRUE or FALSE statements to either 1 or 0
    ## Usage: 'truefalse_onezero varname'
    ## Don't prefix it with a $
    value=$(set | grep "${1}"= | cut -d '=' -f2)
    var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ] ; then
        print_debug "Converting Variable Name ${var} value to '1'"
        unset "$1"
        export "$1=1"
        elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ] ; then
        print_debug "Converting Variable Name ${var} value to '0'"
        unset "$1"
        export "$1=0"
    fi
}

var_false() {
    ## Timesaver for if statements
    ## Usage: if var_false $VARNAME ; then ... fi
    [ "${1,,}" = "false" ] || [ "${1,,}" = "no" ]
}

var_notfalse() {
    [ "${1,,}" != "false" ]
}

var_nottrue() {
    [ "${1,,}" != "true" ]
}

var_true() {
    [ "${1,,}" = "true" ] || [ "${1,,}" = "yes" ]
}

var_value() {
    if [ "${2}" ] ; then
        echo "$(grep -oE "^${1}=.*" "${2}" | grep -oP "(?<==).*")"
    else
        echo "$(set -o posix ; set | grep -oE "^${1}=.*" | grep -oP "(?<==).*")"
    fi
}

wait_for_directory() {
    ## Wait for Directory to exist
    ## Usage: wait_for_directory socketname
    print_debug "Looking for existence of directory: $1"
    while [ ! -d "${1}" ] ; do
        sleep 1
    done
}

wait_for_file() {
    ## Wait for File to exist
    ## Usage: wait_for_file filename
    print_debug "Looking for existence of file: $1"
    while [ ! -f "${1}" ] ; do
        sleep 1
    done
}

wait_for_process() {
    ## Wait for Process to start
    ## Usage: wait_for_process hostname port
    print_debug "Looking for existence of process: $1"
    counter=0
    while ! pgrep "${1}" > /dev/null ; do
        sleep 5
        (( counter+=5 ))
        print_warn "Waiting for '${1}' to start, retrying.. ($counter seconds so far)"
    done
}

wait_for_port() {
    ## Wait for Port to exist
    ## Usage: wait_for_port hostname port
    print_debug "Looking for existence of listening port on $1:$2"
    counter=0
    while ! (nc -z "${1}" "${2}") ; do
        sleep 5
        (( counter+=5 ))
        print_warn "Host '${1}' is not listening on port '${2}', retrying.. ($counter seconds so far)"
    done
}

wait_for_socket() {
    ## Wait for Socket to exist
    ## Usage: wait_for_socket socketname
    print_debug "Looking for existence of socket: $1"
    while [ ! -S "${1}" ] ; do
        sleep 1
    done
}

yesno_truefalse() {
    ## Convert YES or NO statements to either TRUE or FALSE
    ## Usage: 'yesno_truefalse varname'
    ## Don't prefix it with a $
    ## Optionally add "uppercase" / "lowercase" as second value on how you wish it to be replaced
    value=$(set | grep "${1}"= | cut -d '=' -f2)
    var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ] ; then
        print_debug "Converting Variable Name ${var} value to 'yes'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=TRUE"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=true"
                ;;
            esac
        else
            export "$1=TRUE"
        fi
        elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ] ; then
        print_debug "Converting Variable Name ${var} value to 'no'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "$2" in
                "uppercase" | "upper" | "uc" )
                    export "$1=FALSE"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=false"
                ;;
            esac
        else
            export "$1=FALSE"
        fi
    fi
}
