# SPDX-FileCopyrightText: Â© 2025 Nfrastack <code@nfrastack.com>
#
# SPDX-License-Identifier: MIT

package() {
    cleanup() {
        case "${distro}" in
            "alpine" )
                rm -rf /var/cache/apk/*
            ;;
            "debian" | "ubuntu" )
                apt-get clean -y
                rm -rf /var/lib/apt/lists/*
            ;;
        esac

        rm -rf \
                /build-assets \
                /etc/logrotate.d/* \
                /root/.cache \
                /root/.cargo \
                /root/.composer \
                /root/.gitconfig \
                /root/.npm \
                /root/go \
                /tmp/* \
                /usr/src/* \
                /var/log/* \
                /var/tmp/*
    }

    ## Looks for environment variable suffixed with _OS and then either explodes the list or creates the package list depending on OS. If there is no match, then wait until the end of the loop and install packages.
    ## Usage: package install BUILD_DEPS packagename packagename
    install() {
        local _packages_to_install
        case "${distro}" in
            "alpine" )
                _package_install_list="$@"
                if [[ "${1}" =~ ^\..* ]] ; then
                    local dependencies="-t "
                    apk add -t $@
                else
                    for _package in $_package_install_list ; do
                        if [ -v "${_package^^}"_ALPINE ] ; then
                           local _packages
                           _packages=$(set -o posix; set | grep -E "^${_package^^}_ALPINE" | cut -d = -f 2 | sed 's/ \{1,\}/ /g' | xargs)
                           apk add -t ."${_package,,}" ${_packages}
                        else
                           _packages_to_install+=" ${_package} "
                        fi
                    done
                    if [ -n "${_packages_to_install}" ] ; then
                        apk add ${_packages_to_install}
                    fi
                fi
            ;;
            "debian" | "ubuntu" )
                _package_install_list="$@"
                if [[ "${1}" =~ ^\..* ]] ; then
                    shift
                    apt-get install -y --no-install-recommends $@
                else
                    for _package in $_package_install_list ; do
                        if [ -v "${_package^^}"_DEBIAN ] ; then
                            local _packages
                            _packages=$(set -o posix; set | grep -E "^${_package^^}_DEBIAN" | cut -d = -f 2 | sed 's/ \{1,\}/ /g' | xargs)
                            apt-get install -y --no-install-recommends ${_packages}
                         else
                             _packages_to_install+=" ${_package} "
                         fi
                     done
                         if [ -n "${_packages_to_install}" ] ; then
                             apt-get install -y --no-install-recommends ${_packages_to_install}
                         fi
                 fi
            ;;
        esac
    }

    ## Looks for environment variable suffixed with _OS and then either explodes the list or references the package list depending on OS. If there is no match, then wait until the end of the loop and uninstall
    ## Usage: package remove BUILD_DEPS packagename packagename
    remove() {
        case "${distro}" in
            "alpine" )
                _package_removal_list="$@"
                for _package in $_package_removal_list ; do
                    if [ -v "${_package^^}"_ALPINE ] ; then
                        _package_removal_list=$(echo "$_package_removal_list" | sed -e "s|${_package^^}_ALPINE||g" -e "s|${_package^^}||g")
                        _package_removal_list+=" .${_package,,} "
                   else
                        _package_removal_list+=" ${_package} "
                    fi
                done

                apk del $_package_removal_list
            ;;
            "debian" | "ubuntu" )
                _package_removal_list="$@"
                for _package in $_package_removal_list ; do
                    if [ -v "${_package^^}"_DEBIAN ] ; then
                        _package_removal_list+=$(set -o posix; set | grep -E "^${_package^^}_DEBIAN" | cut -d = -f 2 | sed 's/ \{1,\}/ /g' | xargs)
                        _package_removal_list=$(echo "$_package_removal_list" | sed -e "s|${_package^^}_DEBIAN||g" -e "s|${_package^^}||g")
                    else
                        _package_removal_list+=" ${_package} "
                    fi
                done

                if [[ "${_packages_removal_list}" =~ \..* ]] ; then
                    _package_removal_list=$(echo "${_package_removal_list}" | sed "s|\..* ||g")
                fi

                apt-get purge -y ${_package_removal_list}
                apt-get autoremove -y
            ;;
        esac
    }

    repo() {
        ## Usage:
        ##   package repo add <repo_name> <repo_url_and_suite> [keyring_name]
        ##     package repo add myrepo "https://example.com/apt stable main" example-archive-keyring.gpg
        ##     This will create /etc/apt/sources.list.d/myrepo.list with the correct signed-by reference if keyring_name is provided.
        ##   package repo key <url> <keyring_name>
        ##     package repo key https://example.com/repo.gpg example-archive-keyring.gpg
        ##     This will create /usr/share/keyrings/example-archive-keyring.gpg for use in sources.list
        case "${1}" in
            add )
                case "${distro}" in
                    "alpine" )
                        if [ -n "${3}" ] ; then
                            _package_repo_name="${2}"
                            shift 2
                            echo "$@" > /etc/apk/repositories/"${_package_repo_name}"
                        fi
                    ;;
                    "debian" | "ubuntu" )
                        _package_repo_name="${2}"
                        repo_line="${3}"
                        keyring_name="${4}"
                        if [ -n "${keyring_name}" ]; then
                            echo "deb [signed-by=/usr/share/keyrings/${keyring_name}] ${repo_line}" > /etc/apt/sources.list.d/"${_package_repo_name}".list
                        else
                            echo "deb ${repo_line}" > /etc/apt/sources.list.d/"${_package_repo_name}".list
                        fi
                    ;;
                esac
            ;;
            key )
                ## apt-key is gone with trixie and newer
                ## package repo key <url> <keyring_name>
                ## package repo key https://example.com/repo.gpg example-archive-keyring.gpg
                ## This will create /usr/share/keyrings/example-archive-keyring.gpg for use in sources.list
                case "${distro}" in
                    "debian" | "ubuntu" )
                        local key_url="${2}"
                        local keyring_name="${3:-example-archive-keyring.gpg}"
                        curl -fsSL "${key_url}" | gpg --dearmor -o "/usr/share/keyrings/${keyring_name}"
                    ;;
                esac
            ;;
        esac
    }

    update() {
        case "${distro}" in
            "alpine" )
                apk update
            ;;
            "debian" | "ubuntu" )
                apt-get update
            ;;
        esac
    }

    upgrade() {
        case "${distro}" in
            "alpine" )
                apk upgrade
            ;;
            "debian" | "ubuntu" )
                apt-get upgrade -y
            ;;
        esac
    }

    output_off
    local distro
    distro=$(container_info distro)
    local action="${1}"
    shift
    local arguments=$@

    case "${action}" in
        add | install )
            action=install
            "${action}" "${arguments}"
        ;;
        delete | remove | uninstall )
            action=remove
            "${action}" "${arguments}"
        ;;
        repo )
            action=repo
            "${action}" ${arguments}
        ;;
        * )
            "${action}" ${arguments}
        ;;
    esac
    output_on
}
