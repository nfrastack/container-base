# SPDX-FileCopyrightText: Â© 2026 Nfrastack <code@nfrastack.com>
#
# SPDX-License-Identifier: MIT

create_folder() {
    ## Creates a folder with the specified permissions and ownership
    ## Usage: create_folder <folder_path> <user[:group]> <permissions> [norecurse] [force]
    ## If the folder path is seperated with commas, it will create all of them.
    ## If the folder already exists, it will not be recreated.
    ## If the user:group is not specified, it will not change ownership.
    ## If the permissions are not specified, it will not change permissions.
    ## If 'norecurse' is specified, chown/chmod will not use -R (recursive).
    ## If 'force' is specified, chown/chmod will always run.

    local recurse_flag="-R"
    local force_flag=""
    for arg in "$@"; do
        if [ "$arg" = "norecurse" ]; then
            recurse_flag=""
        fi
        if [ "$arg" = "force" ]; then
            force=true
        fi
    done

    if [ -n "${1}" ]; then
        for folder in $(echo "${1}" | tr ',' ' '); do
            folder=$(echo "$folder" | xargs)
            if [ ! -d "${folder}" ] ; then
                mkdir -p "${folder}"
            fi

            if [ -n "${2}" ]; then
                if [[ "${2}" == *:* ]]; then
                    current_owner_group=$(stat -c "%U:%G" "$folder")
                    if [ "$current_owner_group" != "${2}" ] || [ "${force}" = "true" ]; then
                        chown ${recurse_flag} "${2}" "$folder"
                    fi
                else
                    current_owner=$(stat -c "%U" "$folder")
                    if [ "$current_owner" != "${2}" ] || [ "${force}" = "true" ]; then
                        chown ${recurse_flag} "${2}" "$folder"
                    fi
                fi
            fi

            if [ -n "${3}" ]; then
                current_perms=$(stat -c "%a" "$folder")
                if [ "$current_perms" != "${3}" ] || [ -n "$force_flag" ]; then
                    chmod ${recurse_flag} "${3}" "$folder"
                fi
            fi
        done
    fi
}

custom_files() {
    ## Copy files from one lcoation to somewhere else on the file system
    ## eg. Copy all files in /override/custom (Default ENV CONTAINER_CUSTOM_PATH) to /www/html  'custom_files /www/html'
    ## Add another parameter if you want to move any source folder to a destination ie `custom_files /override/customfolder2/ /destination`
    ## The third and fourth parameters if exist will change ownership to the user:group
    if [ -n "${2}" ] ; then
        ccustom_files_source="${1}"
        ccustom_files_destination="${2}"
    else
        ccustom_files_source="${CONTAINER_CUSTOM_PATH}"
        ccustom_files_destination="${1}"
    fi

    if [ -d "${ccustom_files_source}" ] && dir_notempty "${ccustom_files_source}" ; then
        print_debug "Custom Files: Copying files from '${ccustom_files_source}' to '${ccustom_files_destination}'"
        if [ -d "${ccustom_files-destination}" ] ; then
            mkdir -p "${ccustom_files-destination}"
        fi
        cp -aR "${ccustom_files_source}"/* "${ccustom_files_destination}"/
    fi

    if [ -n "${3}" ] ; then permbuilder="${3}" ; fi
    if [ -n "${4}" ] ; then permbuilder="${3}:${4}" ; fi
    if [ -n "${permbuilder}" ] ; then chown -R "${permbuilder}" "${2}" ; fi
}

custom_scripts() {
    ## Execute Custom scripts out of this directory
    if [ -n "${1}" ] ; then
        ccustom_scripts_source="${1}"
    else
        ccustom_scripts_source="${CONTAINER_CUSTOM_SCRIPTS_PATH}"
    fi

    if [ -d "${ccustom_scripts_source}" ] && dir_notempty "${ccustom_scripts_source}" ; then
        for ccustom_script in "${ccustom_scripts_source}"/*.sh ; do
            if [ -x "$ccustom_script" ] && [ ! -d "$ccustom_script" ] ; then
                print_debug "Custom Script executing: '${ccustom_script}'"
                ${ccustom_script}
            fi
        done
    fi
}

install_template() {
    ## Copies configuration template to the destination as the specified USER
    ## Usage install_template <copy-as-user> <source_file> <desintation_location+file> <optional chmod mode>

    if [ -z "${1}" ] || [ -z "${2}" ] || [ -z "${3}" ] ; then
        print_error "[install_template] No arguments passed"
        exit 1
    fi

    local template_mode=${4:-"0644"}
    if [ ! -f "$2" ]; then
        print_error "[install_template] Can't find ${2}"
        exit 1
    fi

    if [ ! -d "$(dirname "${3}")" ] ; then
        mkdir -p "$(dirname "${3}")"
    fi

    chmod "${template_mode}" "${3}"
    chown "${1}" "${DEST}"
}

render_template() {
    ## Copy a source template to a destination and replace placeholders with values
    ## Usage: render_template [newline] <source_file> <destination_file> <varname> ...
    ## If 'newline' is the first argument, \n will be replaced with real newlines
    ## Can have multiple varnames - Don't prefix the varname with $

    local newline_mode=false
    if [ "${1,,}" = "newline" ]; then
        newline_mode=true
        shift
    fi

    local source_file=${1:-} dest_file=${2:-}
    shift 2 || true
    if [ -z "${source_file}" ] || [ -z "${dest_file}" ] ; then
        print_error "[render_template] Missing source or destination"
        return 1
    fi

    if [ ! -d "$(dirname "${dest_file}")" ]; then
        mkdir -p "$(dirname "${dest_file}")"
    fi

    cp -a "${source_file}" "${dest_file}"

    local template_tmp_file
    template_tmp_file=$(mktemp)
    cp -a "${dest_file}" "${template_tmp_file}"

    for template_variable in "${@}"; do
        eval "val=\"\${${template_variable}-}\""
        esc_val=$(printf '%s' "${val}" | sed -e 's/\\/\\\\/g' -e 's/|/\\|/g' -e 's/&/\\&/g')
        sed -i "s|{{${template_variable}}}|${esc_val}|g" "${template_tmp_file}" || true
        print_debug "[render_template_local] Template: '${dest_file}' updating field '${template_variable}'"
    done

    if [ "${newline_mode,,}" = true ] ; then
        sed -i 's/\\n/\n/g'  "${template_tmp_file}" > "${template_tmp_file}.new" && mv "${template_tmp_file}.new" "${template_tmp_file}"
    fi

    mv "${template_tmp_file}" "${dest_file}"
    chmod 644 "${dest_file}"
}

update_template() {
    ## Replace placeholders with values
    ## Usage: update_template [newline] <filename> <varname> ...
    ## If 'newline' is the first argument, \n will be replaced with real newlines
    ## Can have multiple varnames - Don't prefix the varname with $
    local newline_mode
    if [ "${1}" = "newline" ]; then
        newline_mode=true
        shift
    fi
    template_files=${1}
    templates=$(echo "${template_files}" | tr " " "\n")
    shift
    for template_file in $templates; do
        [[ ! -f "${template_file}" ]] && return 1
        template_variables=($@)
        template_user=$(stat -c %U "${template_file}")
        template_tmp_file=$(mktemp)
        cp -a "${template_file}" "${template_tmp_file}"
        # Keep the compatibilty: {{VAR}} => ${VAR}
        for template_variable in ${template_variables[@]}; do
            sed -ri "s/[{]{2}$template_variable[}]{2}/\${$template_variable}/g" "${template_tmp_file}"
            print_debug "[update_template] Template: '${template_file}' updating field '${template_variable}'"
        done
        (
            export ${template_variables[@]}
            local IFS=":"; sudo -HEu ${template_user} envsubst "${template_variables[*]/#/$}" < "${template_tmp_file}" > "${template_file}"
        )
        if var_true "${newline_mode}" ; then
            # Convert escaped newlines to real newlines
            sed -i 's/\\n/\n/g' "${template_file}"
        fi
        rm -f "${template_tmp_file}"
        continue

        mv "${template_tmp_file}" "${template_file}"
    done
}

write_file() {
    ## Usage: write_file [-a] <user> <file> [file...]
    ## herdocs work
    local append="false"
    if [ "${1}" = "-a" ]; then
        append="true"
        shift
    fi
    if [ -z "${1}" ]; then
        print_error "[write_file] Missing user or filename"
        return 1
    fi

    local ucan="${1}"
    local user=""
    local owner_spec=""

    if [[ "${ucan}" == *:* ]]; then
        local userpart="${ucan%%:*}"
        local grouppart="${ucan##*:}"
        if getent passwd "${userpart}" >/dev/null 2>&1; then
            user="${userpart}"
            if [ -n "${grouppart}" ] && getent group "${grouppart}" >/dev/null 2>&1; then
                owner_spec="${user}:${grouppart}"
            else
                owner_spec="${user}"
                if [ -n "${grouppart}" ]; then
                    print_debug "Group '${grouppart}' not found; using owner '${owner_spec}'"
                fi
            fi
            shift || true
        else
            user="${SUDO_USER:-root}"
            owner_spec="${user}"
        fi
    else
        if getent passwd "${ucan}" >/dev/null 2>&1; then
            user="${ucan}"
            owner_spec="${user}"
            shift || true
        else
            user="${SUDO_USER:-root}"
            owner_spec="${user}"
        fi
    fi

    if [ $# -lt 1 ]; then
        print_error "[write_file] Missing filename(s)"
        return 1
    fi

    local -a targets=()
    local -a modes=()
    local arg
    for arg in "$@"; do
        if [[ "${arg}" == *:* ]]; then
            local base="${arg%%:*}"
            local cand_mode="${arg##*:}"
            if [[ "${cand_mode}" =~ ^[0-7]{3,4}$ ]] && [ -n "${base}" ]; then
                targets+=("${base}")
                modes+=("${cand_mode}")
                continue
            fi
        fi
        targets+=("${arg}")
        modes+=("")
    done

    local i
    for i in "${!targets[@]}"; do
        f="${targets[$i]}"
        if [ "${append}" = "true" ]; then
            print_debug "[write_file] Appending to '${f}' as user '${user}'"
        else
            print_debug "[write_file] Writing to '${f}' as user '${user}'"
        fi
        local parent_dir
        parent_dir=$(dirname "${f}")
            if [ ! -d "${parent_dir}" ]; then
                mkdir -p "${parent_dir}"
            fi
    done

    if [ "${append}" = "true" ]; then
        silent sudo -u root tee -a -- "${targets[@]}"
    else
        silent sudo -u root tee -- "${targets[@]}"
    fi

    for i in "${!targets[@]}"; do
        if [ -n "${modes[$i]}" ]; then
            chmod "${modes[$i]}" "${targets[$i]}" || true
            print_debug "[write_file] Set mode ${modes[$i]} on ${targets[$i]}"
        fi
        if [ -n "${owner_spec}" ]; then
            chown "${owner_spec}" "${targets[$i]}" || true
            print_debug "[write_file] Set owner ${owner_spec} on ${targets[$i]}"
        fi
    done
}

