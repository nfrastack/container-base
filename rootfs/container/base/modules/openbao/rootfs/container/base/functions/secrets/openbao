# SPDX-FileCopyrightText: Â© 2025 Nfrastack <code@nfrastack.com>
#
# SPDX-License-Identifier: MIT

_nfra_secrets_openbao() {
    if var_true "${OPENBAO_CREATE_ENV}" ; then
        _nfra_secrets_openbao_bootstrap
        _nfra_secrets_openbao_extract_tokens "${SECRET_IDENTITY}" "${SECRET_TARGET_PATH}"
    fi
}

_nfra_secrets_openbao_bootstrap() {
    print_info "(${secret}) Fetching secrets via 'openbao' backend"

    # Map SECRET_HOST to VAULT_ADDR
    if [ -n "${SECRET_HOST}" ]; then
        export VAULT_ADDR="${SECRET_HOST}"
    elif [ -n "${VAULT_ADDR}" ]; then
        export VAULT_ADDR="${VAULT_ADDR}"
    elif [ -n "${OPENBAO_ADDR}" ]; then
        print_warn "(${secret}) OPENBAO_ADDR is set. Mapping it to VAULT_ADDR for compatibility."
        export VAULT_ADDR="${OPENBAO_ADDR}"
    else
        print_error "(${secret}) VAULT_ADDR is not set, and no SECRET_HOST is available."
        exit 1
    fi

    # Map SECRET_TOKEN to VAULT_TOKEN
    if [ -n "${SECRET_TOKEN}" ]; then
        export VAULT_TOKEN="${SECRET_TOKEN}"
    elif [ -z "${VAULT_TOKEN}" ]; then
        print_error "(${secret}) VAULT_TOKEN is not set, and no SECRET_TOKEN is available."
        exit 1
    fi

    # Validate Vault authentication
    if ! vault token lookup > /dev/null 2>&1; then
        print_error "(${secret}) Failed to authenticate with Vault. Please check your SECRET_TOKEN."
        exit 1
    fi
}

_nfra_secrets_openbao_list_secret_stores() {
    vault secrets list -format=json 2>/dev/null | \
        awk '
            BEGIN { RS="},"; FS=":" }
            /"type": "kv"/ {
                for (i = 1; i <= NF; i++) {
                    if ($i ~ /"type"/) {
                        path = substr($1, 2, length($1) - 2)
                        print path
                    }
                }
            }
        ' | \
        tr -d '",'
}

_nfra_secrets_openbao_extract_tokens() {
    local output_location="${2:-${SECRET_TARGET_PATH}}" # Correctly assign the second argument to output_location
    local stores

    if [ "${1,,}" = "all" ]; then
        # List all available secret stores of type 'kv'
        stores=$(_nfra_secrets_openbao_list_secret_stores | awk 'NF' | xargs) # Remove blank and whitespace-only lines
        if [ -z "$stores" ]; then
            print_error "(${secret}) No 'kv' secret stores available or failed to retrieve stores."
            return 1
        fi
    else
        # If a specific store is provided, validate it
        stores="$1"
        if ! _nfra_secrets_openbao_list_secret_stores | grep -q "^$1$"; then
            print_error "(${secret}) Specified store '$1' not found in available 'kv' stores."
            return 1
        fi
    fi

    # Format stores as a single line with single quotes for debug output
    local formatted_stores
    formatted_stores=$(echo "$stores" | tr ' ' '\n' | awk 'NF' | tr '\n' ' ' | sed "s/^/'/;s/ $/'/;s/ /' '/g")
    print_debug "(${secret}) Available Secret Stores of type 'kv': $formatted_stores"

    # Process each store
    echo "$stores" | tr ' ' '\n' | awk 'NF' | while IFS= read -r store; do
        # Sanitize the store name to remove debug output or invalid characters
        store=$(echo "$store" | sed 's/\[[^]]*\]//g' | xargs)
        if [ -z "$store" ]; then
            print_debug "(${secret}) Skipping empty store entry."
            continue
        fi

        print_debug "(${secret}) [${store}] Processing store"
        _nfra_secrets_openbao_extract_tokens_from_store "$store" "$output_location" "$secret"
    done
}

_nfra_secrets_openbao_extract_tokens_from_store() {
    local store_path="$1"
    local output_location="$2"
    local secret="$3"

    [[ "${store_path}" != */ ]] && store_path="${store_path}/"

    store_path=$(echo "$store_path" | sed 's/\[[^]]*\]//g' | xargs)

    print_debug "(${secret}) [${store}] Extracting tokens from store: $store_path"
    print_debug "(${secret}) [${store}] Output location: $output_location"

    local store_dir
    if [ "${SECRET_TYPE,,}" = "dotenv" ]; then
        # For dotenv, use the output location directly
        store_dir="${output_location}"
    elif [ "${OPENBAO_SECRETS_FLATTEN,,}" = "true" ]; then
        store_dir="${output_location}"
    else
        store_dir="${output_location}/$(basename "${store_path}")"
    fi

    store_dir=$(echo "$store_dir" | sed 's/\[[^]]*\]//g' | xargs)
    if [ ! -d "$store_dir" ]; then
        print_debug "(${secret}) [${store}] Creating store directory: $store_dir"
        mkdir -p "$store_dir"
        if [ $? -ne 0 ]; then
            print_error "(${secret}) [${store}] Failed to create store directory: $store_dir."
            return 1
        fi
    fi

    local openbao_log="${store_dir}/.openbao"

    if [ ! -f "$openbao_log" ]; then
        touch "$openbao_log"
        if [ ${?} -ne 0 ]; then
            print_error "(${secret}) [${store}] Failed to create .openbao log file: $openbao_log."
            return 1
        fi
    fi

    local dotenv_file
    if [ "${SECRET_TYPE,,}" = "dotenv" ]; then
        dotenv_file="${store_dir}/$(echo "${SECRET_SOURCE}" | sed 's|[^a-zA-Z0-9_-]|_|g').env"
        : > "$dotenv_file"
    fi

    secretlist=$(vault kv list "$store_path" 2>/dev/null | tail -n +3)
    if [ -z "$secretlist" ]; then
        print_error "(${secret}) [${store}] No secrets found in store: $store_path."
        return 1
    fi

    while IFS= read -r secretkv; do
        if [ -n "$secretkv" ]; then
            print_debug "(${secret}) [${store}] Fetching secret: ${secretkv} from store: ${store_path}"
            secret_data=$(vault kv get -format=json "${store_path}${secretkv}" 2>/dev/null)
            if [ $? -ne 0 ]; then
                print_error "(${secret}) [${store}] Failed to retrieve secret: ${secretkv} from store: ${store_path}."
                continue
            fi

            echo "${secret_data}" | busybox awk '
                /"data":/ { inside_data = 1; next }
                inside_data && /"metadata":/ { inside_data = 0; next }
                inside_data {
                    gsub(/"|,/, ""); # Remove quotes and commas
                    if ($1 != "" && $2 != "") print $1 ":" $2; # Only process valid key-value pairs
                }
            ' | while IFS=':' read -r key value; do

                key=$(echo "${key}" | xargs | tr -d '\r')
                value=$(echo "${value}" | xargs | tr -d '\r')

                value=$(echo "$value" | sed 's/^://')

                if [ -z "$key" ] || [ -z "$value" ]; then
                    continue
                fi

                if [ "${SECRET_TYPE,,}" = "dotenv" ]; then
                    echo "${key}=${value}" >> "$dotenv_file"
                else
                    local output_file="${store_dir}/${key}"
                    print_debug "(${secret}) [${store}] Writing secret to: ${output_file}"
                    echo -n "${value}" > "${output_file}"
                    if [ ${?} -ne 0 ]; then
                        print_error "(${secret}) [${store}] Failed to write secret: ${key} to file: ${output_file}."
                        continue
                    fi

                    if ! grep -qx "${key}" "$openbao_log"; then
                        echo "${key}" >> "$openbao_log"
                    fi

                    chown "${SECRET_FILE_USER}":"${SECRET_FILE_GROUP}" "${output_file}"
                    chmod "${SECRET_FILE_PERMISSIONS}" "${output_file}"
                    print_debug "(${secret}) [${store}] Wrote secret: ${output_file}"
                fi
            done
        fi
    done <<< "$secretlist"

    if [ "${SECRET_TYPE,,}" = "dotenv" ]; then
        print_debug "(${secret}) [${store}] Wrote dotenv file: ${dotenv_file}"
        chown "${SECRET_FILE_USER}":"${SECRET_FILE_GROUP}" "${dotenv_file}"
        chmod "${SECRET_FILE_PERMISSIONS}" "${dotenv_file}"
    fi

    print_debug "(${secret}) [${store}] All tokens extracted from store: ${store_path}."
}
